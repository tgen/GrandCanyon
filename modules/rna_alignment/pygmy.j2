{% macro pygmy(sample) %}

{% set temp_dir %}temp/{{ sample.gltype }}/pygmy/{{ sample.name }}{% endset %}
{% set results_dir %}{{ sample.gltype }}/pygmy/{{ sample.name }}{% endset %}

{% for rgid, rg in sample.read_groups.items() %}
{% for ubam in rg.ubam_files %}

- name: bamtofastq_{{ sample.name }}
  input: temp/ubams/{{ ubam.basename }}
  output: {{ temp_dir }}/fq/{{ sample.name }}/{{ sample.name }}.fq
  cpus: 2
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.samtools.container }}
  cmd: |

    {# note: this step converts uBAM from dorado to fastq #}
    {# input: uBAM from dorado #}
    {# output: raw fastq #}
    {# uses -T dx option to add simplex/duplex dx flag from BAM to the fastq header #}

    mkdir -p {{ temp_dir }}/fq/{{ sample.name }}

    samtools fastq -T dx temp/ubams/{{ ubam.basename }} > {{ temp_dir }}/fq/{{ sample.name }}/{{ sample.name }}.fq


- name: pychopper_{{ sample.name }}
  input: {{ temp_dir }}/fq/{{ sample.name }}/{{ sample.name }}.fq
  output: {{ temp_dir }}/pychopper/{{ sample.name }}/pychopper_all.fq
  cpus: 10
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.pychopper.container }}
  cmd: |

    {# note: this step runs pychopper, which trims, orients, and rescues reads #}
    {# input: raw fastq #}
    {# output: pychopper chopped and rescued fastq #}

    mkdir -p {{ temp_dir }}/pychopper/{{ sample.name }}

    cdna_cla.toolsier.py \
      -m edlib \
      -t 10 \
      -r {{ temp_dir }}/pychopper/{{ sample.name }}/report.pdf \
      -A {{ temp_dir }}/pychopper/{{ sample.name }}/aln_hits.bed \
      -S {{ temp_dir }}/pychopper/{{ sample.name }}/statistics.tsv \
      -u {{ temp_dir }}/pychopper/{{ sample.name }}/uncla.toolsied.fq \
      -w {{ temp_dir }}/pychopper/{{ sample.name }}/rescued.fq \
      {{ temp_dir }}/fq/{{ sample.name }}/{{ sample.name }}.fq {{ temp_dir }}/pychopper/{{ sample.name }}/full_length_output.fq

    cat {{ temp_dir }}/pychopper/{{ sample.name }}/full_length_output.fq {{ temp_dir }}/pychopper/{{ sample.name }}/rescued.fq \
      > {{ temp_dir }}/pychopper/{{ sample.name }}/pychopper_all.fq


- name: minimap2_SIRV_{{ sample.name }}
  input: {{ temp_dir }}/pychopper/{{ sample.name }}/pychopper_all.fq
  output: 
    - {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_mapped.bam
    - {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.bam
  cpus: 10
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.minimap2.container }}
  cmd: |

    {# note: this step aligns reads to the SIRV spike-in reference. If skipped and sample has spike-ins, some SIRVs will align to the human genome. #}
    {# input: pychopper chopped and rescued fastq #}
    {# output: SIRVome mapped SAM #}

    mkdir -p {{ temp_dir }}/minimap2/{{ sample.name }}

    minimap2 \
      -ax splice \
      --splice-flank=no \
      -t 10 \
      -L \
      {{ constants.grandcanyon.reference_fastaSIRV }} \
      {{ temp_dir }}/pychopper/{{ sample.name }}/pychopper_all.fq |\
    samtools view -bhu -f 4 \
      -o {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_mapped.bam \
      -U {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.bam


- name: minimap2_{{ sample.name }}
  input: {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.bam
  output: 
    - {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam
    - {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.noSecondary.bam
    - {{ sample.name }}_mapped_withSupp_readLength.txt
    - {{ sample.name }}_mapped_noSupp_readLength.txt
    - {{ sample.name }}_unmapped_readLength.txt
  cpus: 10
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.minimap2.container }}
  cmd: |

    {# note: this step converts unmapped SIRV bam to fq #}
    {# input: bam with reads unmapped to SIRVs #}
    {# output: fq with reads unmapped to SIRVs #}

    samtools fastq -@ 4 {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.bam |\
    minimap2 \
      -ax map-ont \
      -t 10 \
      -L {{ constants.grandcanyon.reference_fasta }} \
      {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.fq |\
    samtools sort -@ 4 -m 6G --write-index -O bam -o {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam

    samtools view -hb -F 256 {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam > {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.noSecondary.bam
    samtools index {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.noSecondary.bam

    {#  read lengths: mapped reads only #}
    samtools view -F 4 {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.noSecondary.bam | awk '{print $1,"\t",length($10),"\t","Human"}' > {{ sample.name }}_mapped_withSupp_readLength.txt &
    {#  read lengths: mapped reads only, no supplementary or secondary reads #}
    samtools view -F 4 -F 2048 {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.noSecondary.bam | awk '{print $1,"\t",length($10),"\t","Human"}' > {{ sample.name }}_mapped_noSupp_readLength.txt &
    {#  read lengths: unmapped reads #}
    samtools view -f 4 {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.noSecondary.bam | awk '{print $1,"\t",length($10),"\t","Unmapped"}' > {{ sample.name }}_unmapped_readLength.txt &


- name: minimap2_transcriptome_{{ sample.name }}
  input: {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.fq
  output:{{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.TranscriptomeAligned.out.bam
  cpus: 10
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.minimap2.container }}
  cmd: |

    {# note: this step aligns reads (unmapped to SIRVs) to the human transcriptome #}
    {# input: fq with reads unmapped to SIRVs #}
    {# output: human aligned transcriptome bam for salmon #}
    {# parameters match nanopore workflow https://github.com/nanoporetech/pipeline-transcriptome-de/tree/master #}
    {# -N 100 allows up to 100 secondary alignments (multiple isoforms) #}
    {# -p 1.0 secondary score ratio, this is higher than the default of 0.8 since we are looking for transcriptome isoforms #}

    mkdir -p {{ temp_dir }}/minimap2/{{ sample.name }}

    minimap2 \
      -ax map-ont \
      -t 10 \
      -L \
      -N 100 \
      -p 1.0 \
      {{ constants.grandcanyon.transcriptome }} \
      {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.fq |\
    samtools view -b -o {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.TranscriptomeAligned.out.bam


{% if constants.pipe_params.fc | default(false) %}
- name: featureCounts_{{ sample.name }}
  input: {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam
  output: {{ temp_dir }}/counted/{{ sample.name }}.txt
  cpus: 10
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.featureCounts.container }}
  cmd: |

    {# note: this step performs gene level quantification from the human aligned bam #}
    {# input: human aligned bam #}
    {# output: gene counts #}

    mkdir {{ temp_dir }}/counted
    cd {{ temp_dir }}/counted

    featureCounts \
      -T 10 \
      -t exon \
      -g gene_id \
      -a {{ constants.grandcanyon.gtf }} \
      -L \
      -o {{ sample.name }}.txt \
      {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam
{% endif %}


{% if constants.pipe_params.salmon | default(false) %}
- name: salmon_{{ sample.name }}
  input: {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.TranscriptomeAligned.out.bam
  output: {{ temp_dir }}/salmon-align/{{ sample.name }}
  cpus: 10
  mem: 32G
  output: salmon_{{ sample.name }}_done
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.salmon.container }}
  cmd: |

    {# note: this step performs salmon in alignment mode for transcript quantification #}
    {# input: human aligned transcriptome bam #}
    {# output: quant.sf file with transcript quantification (tpms) #}


    mkdir -p {{ temp_dir }}/salmon-align
    cd {{ temp_dir }}/salmon-align

    salmon quant \
      --no-version-check \
      --libType A \
      --output {{ sample.name }} \
      --threads 10 \
      --numBootstraps 100 \
      --dumpEq \
      --ont \
      --alignments {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.TranscriptomeAligned.out.bam \
      --targets {{ constants.grandcanyon.transcriptome }}
{% endif %}


{% if constants.pipe_params.flair | default(false) %}
- name: flair_{{ sample.name }}
  input: {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam
  output:
    - {{ temp_dir }}/flair/{{ sample.name }}/flair.collapse.isoforms.fa
    - {{ temp_dir }}/flair/{{ sample.name }}/{{ sample.name }}_flair_top10.txt
  cpus: 10
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.flair.container }}
  cmd: |

    {# note: this step performs flair for read correction, annotation, and quantification #}
    {# input: human aligned genome bam #}
    {# output: isoforms.fa, quantification, gtf #}

    mkdir -p {{ temp_dir }}/flair/{{ sample.name }}
    cd {{ temp_dir }}/flair/{{ sample.name }}

    {# we already did alignment, skipping flair align step and converting bam to bed for flair correct #}
    bam2Bed12 -i {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam > flair.aligned.bed
    flair correct -q flair.aligned.bed -g {{ constants.grandcanyon.reference_fasta }} -t 10 -f {{ constants.grandcanyon.gtf }}
    flair collapse -g {{ constants.grandcanyon.reference_fasta }} -r {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}_SIRVome_unmapped.fq -f {{ constants.grandcanyon.gtf }} -q flair_all_corrected.bed -t 10

    {# generate reads_mainfest.tsv file for flair quantify #}
    printf "{{ sample.name }}\t{{ sample.name }}\tbatch1\t{{ ubam }}" > reads_manifest.tsv.tmp
    awk '{gsub("_","", $1)}1' reads_manifest.tsv.tmp | awk '{gsub("_","", $2)}1' | awk '{gsub("_","", $3)}1' > reads_manifest.tsv.tmp2
    sed -i 's/ /\t/g' reads_manifest.tsv.tmp2
    ( printf "\xff\xfe" ; iconv -f utf-8 -t utf-16le reads_manifest.tsv.tmp2 ) > reads_manifest.tsv

    flair quantify -r reads_manifest.tsv -i flair.collapse.isoforms.fa
    flair quantify -r reads_manifest.tsv -i flair.collapse.isoforms.fa --tpm

    {# generate file with the 10 longest isoforms #}
    awk '/^>/ {printf("%s%s\t",(N>0?"\n":""),$0);N++;next;} {printf("%s",$0);} END {printf("\n");}' flair.collapse.isoforms.fa |\
    awk '{printf("%d\t%s\t%s\t%s\n",length($2),$1,$1,$2);}' |\
    sort -t $'\t' -k1,1nr | cut -f 1,2 | head > {{ sample.name }}_flair_top10.txt
{% endif %}


{% if constants.pipe_params.isoquant | default(false) %}
- name: isoquant_{{ sample.name }}
  input: {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam
  output: {{ temp_dir }}/isoquant/{{ sample.name }}
  cpus: 20
  mem: 32G
  walltime: "4:00:00"
  queue_preset: "DEFAULT"
  container: {{ constants.tools.isoquant.container }}
  cmd: |

    {# note: this step performs isoquant for read correction, annotation, and quantification #}
    {# input: human aligned genome bam #}
    {# output: gene and transcript quantification, gtf #}

    mkdir {{ temp_dir }}/isoquant/{{ sample.name }}
    cd {{ temp_dir }}/isoquant/{{ sample.name }}

    isoquant.py --reference {{ constants.grandcanyon.reference_fasta }} \
      -o {{ temp_dir }}/isoquant/{{ sample.name }}/ \
      -g {{ constants.grandcanyon.gtf }} \
      -d nanopore \
      --complete_genedb \
      --bam {{ temp_dir }}/minimap2/{{ sample.name }}/{{ sample.name }}.Aligned.out.sorted.bam \
      --labels {{ sample.name }} \
      -p {{ sample.name }} \
      --sqanti_output \
      --check_canonical \
      -t 20 
{% endif %}

